{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit'\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date();\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const cleanLeadingZerosInNumericSectionValue = (utils, format, value) => {\n  const size = utils.formatByString(utils.date(), format).length;\n  let cleanValue = value;\n\n  // We remove the leading zeros\n  cleanValue = Number(cleanValue).toString();\n\n  // We add enough leading zeros to fill the section\n  while (cleanValue.length < size) {\n    cleanValue = `0${cleanValue}`;\n  }\n  return cleanValue;\n};\nexport const getLetterEditingOptions = (utils, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return utils.getMonthArray(utils.date()).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date();\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const adjustSectionValue = (utils, section, keyCode, sectionsValueBoundaries, activeDate) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const cleanDigitSectionValue = value => {\n    const valueStr = value.toString();\n    if (section.hasLeadingZeros) {\n      return cleanLeadingZerosInNumericSectionValue(utils, section.format, valueStr);\n    }\n    return valueStr;\n  };\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(), section.format);\n      }\n      if (delta > 0 || isStart) {\n        return cleanDigitSectionValue(sectionBoundaries.minimum);\n      }\n      return cleanDigitSectionValue(sectionBoundaries.maximum);\n    }\n    const currentSectionValue = Number(section.value);\n    const newSectionValueNumber = currentSectionValue + delta;\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return cleanDigitSectionValue(sectionBoundaries.minimum);\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return cleanDigitSectionValue(sectionBoundaries.maximum);\n    }\n    return cleanDigitSectionValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n  if (section.contentType === 'digit') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nconst getSectionVisibleValue = (section, willBeRenderedInInput) => {\n  const value = section.value || section.placeholder;\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)\n  // The \\u2068 and \\u2069 are cleaned, but not the \\u200e to notice that an update with same digit occurs\n  if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasLeadingZeros && value.length === 1) {\n    return `\\u2068${value}\\u200e\\u2069`;\n  }\n  if (willBeRenderedInInput) {\n    return `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = sections => {\n  let position = 0;\n  let positionInInput = 1;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, true);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, currentTokenValue) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(), currentTokenValue).length\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(), format).length === 4;\nexport const doesSectionHaveTrailingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(utils.date(), 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(utils.date(), 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(utils.date()), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(utils.date()), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(utils.date()), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(utils.date(), 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nexport const splitFormatIntoSections = (utils, localeText, format, date) => {\n  let startSeparator = '';\n  const sections = [];\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n    const expandedToken = utils.expandFormat(token);\n    if (expandedToken !== token) {\n      return expandedToken;\n    }\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const sectionValue = date == null ? '' : utils.formatByString(date, token);\n    const hasTrailingZeroes = doesSectionHaveTrailingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n      hasLeadingZeros: hasTrailingZeroes,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n  const splitFormat = token => {\n    const escapedParts = getEscapedPartsFromFormat(utils, token);\n    let currentTokenValue = '';\n    for (let i = 0; i < token.length; i += 1) {\n      const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n      const char = token[i];\n      const isEscapedChar = escapedPartOfCurrentChar != null;\n      if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {\n        currentTokenValue += char;\n      } else {\n        // If we are on the opening or closing character of an escaped part of the format,\n        // Then we ignore this character.\n        const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n        if (!isEscapeBoundary) {\n          const expandedToken = commitToken(currentTokenValue);\n          if (expandedToken != null) {\n            splitFormat(expandedToken);\n          }\n          currentTokenValue = '';\n          if (sections.length === 0) {\n            startSeparator += char;\n          } else {\n            sections[sections.length - 1].endSeparator += char;\n          }\n        }\n      }\n    }\n    const expandedToken = commitToken(currentTokenValue);\n    if (expandedToken != null) {\n      splitFormat(expandedToken);\n    }\n  };\n  splitFormat(format);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (cleanedSeparator === '/') {\n        cleanedSeparator = ' / ';\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, false));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = sections => {\n  const formattedArray = sections.map(section => `${section.startSeparator}${getSectionVisibleValue(section, true)}${section.endSeparator}`);\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${formattedArray.join('')}\\u2069`;\n};\nexport const getSectionsBoundaries = utils => {\n  const today = utils.date();\n  const endOfYear = utils.endOfYear(today);\n  const maxDaysInMonth = utils.getMonthArray(today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    return Math.max(acc, daysInMonth);\n  }, 0);\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfYear);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfYear)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfYear)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nexport const mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => sections.reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const clampDaySection = (utils, sections, sectionsValueBoundaries) => {\n  // We try to generate a valid date representing the start of the month of the invalid date typed by the user.\n  const sectionsForStartOfMonth = sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: null,\n      format: section.format,\n      contentType: section.contentType\n    });\n    return _extends({}, section, {\n      value: section.hasLeadingZeros ? cleanLeadingZerosInNumericSectionValue(utils, section.format, dayBoundaries.minimum.toString()) : dayBoundaries.minimum.toString()\n    });\n  });\n  const startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth);\n\n  // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.\n  if (startOfMonth == null || !utils.isValid(startOfMonth)) {\n    return null;\n  }\n\n  // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.\n  return sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: startOfMonth,\n      format: section.format,\n      contentType: section.contentType\n    });\n    if (Number(section.value) <= dayBoundaries.maximum) {\n      return section;\n    }\n    return _extends({}, section, {\n      value: dayBoundaries.maximum.toString()\n    });\n  });\n};\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' '));\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};","map":{"version":3,"names":["_extends","getDateSectionConfigFromFormatToken","utils","formatToken","config","formatTokenMap","Error","join","type","contentType","sectionType","getDeltaFromKeyCode","keyCode","getDaysInWeekStr","format","elements","now","date","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","cleanLeadingZerosInNumericSectionValue","value","size","length","cleanValue","Number","toString","getLetterEditingOptions","getMonthArray","month","startOfDay","endOfDay","adjustSectionValue","section","sectionsValueBoundaries","activeDate","delta","isStart","isEnd","shouldSetAbsolute","cleanDigitSectionValue","valueStr","hasLeadingZeros","adjustDigitSection","sectionBoundaries","currentDate","minimum","maximum","currentSectionValue","newSectionValueNumber","adjustLetterSection","options","currentOptionIndex","indexOf","newOptionIndex","getSectionVisibleValue","willBeRenderedInInput","placeholder","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","position","positionInInput","newSections","i","renderedValue","sectionStr","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","endInInput","start","end","getSectionPlaceholder","localeText","sectionConfig","currentTokenValue","fieldYearPlaceholder","digitAmount","fieldMonthPlaceholder","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","changeSectionValueFormat","currentFormat","newFormat","process","env","NODE_ENV","parse","isFourDigitYearFormat","doesSectionHaveTrailingZeros","formatted0001","setYear","formatted2001","startOfYear","startOfMonth","setHours","setMinutes","getEscapedPartsFromFormat","escapedParts","startChar","endChar","escapedCharacters","regExp","RegExp","match","exec","index","lastIndex","splitFormatIntoSections","commitToken","token","expandedToken","expandFormat","sectionValue","hasTrailingZeroes","modified","splitFormat","escapedPartOfCurrentChar","find","escapeIndex","char","isEscapedChar","isEscapeBoundary","cleanSeparator","separator","cleanedSeparator","includes","getDateFromDateSections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForInputFromSections","formattedArray","getSectionsBoundaries","today","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","Math","max","year","getMonth","day","isValid","daysInWeek","min","hours","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","setDate","getDate","isAM","mergedDateHours","addHours","setSeconds","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","mergedDate","isAndroid","navigator","userAgent","toLowerCase","clampDaySection","sectionsForStartOfMonth","dayBoundaries","getSectionOrder","isRTL","neighbors","forEach","_","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","_section$endSeparator","rtlIndex"],"sources":["F:/vehicle-rental-booking/frontend/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit'\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date();\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const cleanLeadingZerosInNumericSectionValue = (utils, format, value) => {\n  const size = utils.formatByString(utils.date(), format).length;\n  let cleanValue = value;\n\n  // We remove the leading zeros\n  cleanValue = Number(cleanValue).toString();\n\n  // We add enough leading zeros to fill the section\n  while (cleanValue.length < size) {\n    cleanValue = `0${cleanValue}`;\n  }\n  return cleanValue;\n};\nexport const getLetterEditingOptions = (utils, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return utils.getMonthArray(utils.date()).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date();\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const adjustSectionValue = (utils, section, keyCode, sectionsValueBoundaries, activeDate) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const cleanDigitSectionValue = value => {\n    const valueStr = value.toString();\n    if (section.hasLeadingZeros) {\n      return cleanLeadingZerosInNumericSectionValue(utils, section.format, valueStr);\n    }\n    return valueStr;\n  };\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(), section.format);\n      }\n      if (delta > 0 || isStart) {\n        return cleanDigitSectionValue(sectionBoundaries.minimum);\n      }\n      return cleanDigitSectionValue(sectionBoundaries.maximum);\n    }\n    const currentSectionValue = Number(section.value);\n    const newSectionValueNumber = currentSectionValue + delta;\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return cleanDigitSectionValue(sectionBoundaries.minimum);\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return cleanDigitSectionValue(sectionBoundaries.maximum);\n    }\n    return cleanDigitSectionValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n  if (section.contentType === 'digit') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nconst getSectionVisibleValue = (section, willBeRenderedInInput) => {\n  const value = section.value || section.placeholder;\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)\n  // The \\u2068 and \\u2069 are cleaned, but not the \\u200e to notice that an update with same digit occurs\n  if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasLeadingZeros && value.length === 1) {\n    return `\\u2068${value}\\u200e\\u2069`;\n  }\n  if (willBeRenderedInInput) {\n    return `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = sections => {\n  let position = 0;\n  let positionInInput = 1;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, true);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, currentTokenValue) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(), currentTokenValue).length\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(), format).length === 4;\nexport const doesSectionHaveTrailingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(utils.date(), 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(utils.date(), 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(utils.date()), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(utils.date()), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(utils.date()), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(utils.date(), 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nexport const splitFormatIntoSections = (utils, localeText, format, date) => {\n  let startSeparator = '';\n  const sections = [];\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n    const expandedToken = utils.expandFormat(token);\n    if (expandedToken !== token) {\n      return expandedToken;\n    }\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const sectionValue = date == null ? '' : utils.formatByString(date, token);\n    const hasTrailingZeroes = doesSectionHaveTrailingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n      hasLeadingZeros: hasTrailingZeroes,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n  const splitFormat = token => {\n    const escapedParts = getEscapedPartsFromFormat(utils, token);\n    let currentTokenValue = '';\n    for (let i = 0; i < token.length; i += 1) {\n      const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n      const char = token[i];\n      const isEscapedChar = escapedPartOfCurrentChar != null;\n      if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {\n        currentTokenValue += char;\n      } else {\n        // If we are on the opening or closing character of an escaped part of the format,\n        // Then we ignore this character.\n        const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n        if (!isEscapeBoundary) {\n          const expandedToken = commitToken(currentTokenValue);\n          if (expandedToken != null) {\n            splitFormat(expandedToken);\n          }\n          currentTokenValue = '';\n          if (sections.length === 0) {\n            startSeparator += char;\n          } else {\n            sections[sections.length - 1].endSeparator += char;\n          }\n        }\n      }\n    }\n    const expandedToken = commitToken(currentTokenValue);\n    if (expandedToken != null) {\n      splitFormat(expandedToken);\n    }\n  };\n  splitFormat(format);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (cleanedSeparator === '/') {\n        cleanedSeparator = ' / ';\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, false));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = sections => {\n  const formattedArray = sections.map(section => `${section.startSeparator}${getSectionVisibleValue(section, true)}${section.endSeparator}`);\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${formattedArray.join('')}\\u2069`;\n};\nexport const getSectionsBoundaries = utils => {\n  const today = utils.date();\n  const endOfYear = utils.endOfYear(today);\n  const maxDaysInMonth = utils.getMonthArray(today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    return Math.max(acc, daysInMonth);\n  }, 0);\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfYear);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfYear)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfYear)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nexport const mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => sections.reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const clampDaySection = (utils, sections, sectionsValueBoundaries) => {\n  // We try to generate a valid date representing the start of the month of the invalid date typed by the user.\n  const sectionsForStartOfMonth = sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: null,\n      format: section.format,\n      contentType: section.contentType\n    });\n    return _extends({}, section, {\n      value: section.hasLeadingZeros ? cleanLeadingZerosInNumericSectionValue(utils, section.format, dayBoundaries.minimum.toString()) : dayBoundaries.minimum.toString()\n    });\n  });\n  const startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth);\n\n  // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.\n  if (startOfMonth == null || !utils.isValid(startOfMonth)) {\n    return null;\n  }\n\n  // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.\n  return sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: startOfMonth,\n      format: section.format,\n      contentType: section.contentType\n    });\n    if (Number(section.value) <= dayBoundaries.maximum) {\n      return section;\n    }\n    return _extends({}, section, {\n      value: dayBoundaries.maximum.toString()\n    });\n  });\n};\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' '));\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}